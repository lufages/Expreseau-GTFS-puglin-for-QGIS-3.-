# -*- coding: utf-8 -*-
"""
/***************************************************************************
 expreseau_gtfs_qgis
                                 A QGIS plugin
 Application librairie expreseau_gtfs
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-12-11
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Lucas FAGES
        email                : lucas.fages@cnrs.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from .resources import *
from .ptal import PTAL
# Import the code for the dlg
from .ExpreseauGTFS_dockwidget import expreseau_gtfs_qgisDockWidget
import os.path
import pandas as pd
import os
from .PointCaptureTool import PointCaptureTool
from datetime import datetime, timedelta
from expreseau_gtfs.sections import sections

# from .expreseau_gtfs_app_dialog import expreseau_gtfs_appDialog
from qgis.core import QgsVectorLayer,  QgsFeature, QgsGeometry, QgsProject, QgsField
from PyQt5.QtCore import QVariant
import os.path

from expreseau_gtfs.feed import gtfs_feed
from expreseau_gtfs.performances import performances
from expreseau_gtfs.graphes import graphes
from expreseau_gtfs.utils import nbc_to_gdf, nxbetweenness_to_df
import networkx as nx
import tempfile
import numpy as np
from shapely import Point, LineString
import geopandas as gpd



class expreseau_gtfs_qgis:
    """QGIS Plugin Implementation."""

    def __init__(self, iface, graph=nx.DiGraph(), graphe = None):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface


        # initialise le graphe networkX :
        self._graph = graph
        # intialise l'objet expreseau_gtfs.graphes() :
        self._graphe = graphe
 
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'expreseau_gtfs_qgis_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&ExpreseauGTFS')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'expreseau_gtfs_qgis')
        self.toolbar.setObjectName(u'expreseau_gtfs_qgis')

        #print "** INITIALIZING expreseau_gtfs_qgis"

        self.pluginIsActive = False
        self.dlg = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('expreseau_gtfs_qgis', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ExpreseauGTFS/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dlg is closed"""

        self.dlg.closingPlugin.disconnect(self.onClosePlugin)
        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD expreseau_gtfs_qgis"

        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&ExpreseauGTFS'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dlg == None:
                # Create the dlg (after translation) and keep reference
                self.dlg = expreseau_gtfs_qgisDockWidget()

            # connect to provide cleanup on closing of dlg
            self.dlg.closingPlugin.connect(self.onClosePlugin)

            # show the dlg
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dlg)
            self.dlg.show()

            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dlg)
            self.dlg.show()    
                
            # remplir la combobox d'indicateurs :
            liste_indicateurs = ["route_short_name","direction_id","services par jour",
                                "freq. moy. de 7 à 9","freq. moy. de 12 à 14",
                                "freq. moy. de 16 à 19", "hmin","hmax", "amplitude(sec.)",
                                "freq. moy. corrigee   -    7 a 9", "freq. moy. corrigee   -    12 a 14",
                                "freq. moy. corrigee   -    16 a 19"]
            for indicateur in liste_indicateurs:
                self.dlg.combo_select_indicators.addItemWithCheckState(text=indicateur,
                                                         state = Qt.CheckState.Checked)
            #♦remplir la combobox des algo disponibles
            self.dlg.combo_algo.addItem("Dijsktra with max transfers")
            self.dlg.combo_algo.addItem("Dijsktra")
            self.dlg.combo_algo.addItem("Shortest path")
            

            
            
            self.dlg.gtfs_finder.fileChanged.connect(self.change_networks_name)
            self.dlg.push_draw_network.clicked.connect(self.map_network)
            self.dlg.push_draw_frq.clicked.connect(self.map_freq)
            self.dlg.push_draw_frq_segment.clicked.connect(self.map_seg_freq)
            
            # graph tools :
            self.dlg.push_closeness_centrality.clicked.connect(self.closeness_centrality)
            self.dlg.push_betweenness_centrality.clicked.connect(self.betweenness_centrality)
            self.dlg.push_degree_centrality.clicked.connect(self.degree_centrality)
            
            # Créer l'outil de capture des clics
            # Initialiser le canvas et l'outil de capture
            self.canvas = self.iface.mapCanvas()
            self.captureTool = PointCaptureTool(self.canvas)
            # self.point_layer = self.create_point_layer()
            self.captureTool.pointCaptured.connect(self.add_point_to_layer)
            self.captureTool.pointCaptured.connect(self.handlePointCaptured)
        
            # Suivre le bouton actif
            self.activeButton = None
            
            
            
            self.dlg.push_select_iso_point.clicked.connect(lambda: self.activateCaptureTool("iso"))
            self.dlg.push_select_departure_point.clicked.connect(lambda: self.activateCaptureTool('dep'))
            self.dlg.push_select_arrival_point.clicked.connect(lambda: self.activateCaptureTool("arr"))
            
            
            # trace des isochrones
            self.dlg.push_compute_iso.clicked.connect(self.plot_isochrones)
            self.dlg.push_compute_route.clicked.connect(self.compute_route)
            
            
            # plot evolution
            self.dlg.push_plot_ev.clicked.connect(self.plot_evolution)
            
            # table perfs
            self.dlg.push_overall_table.clicked.connect(self._get_perfs)
            
            # active row flies factor edition
            self.dlg.checkBox_cff.stateChanged.connect(self._change_status_cbx)
            
            self.dlg.checkbox_geoservice_pedestrians.stateChanged.connect(self._change_status_pedestrian)
            self.dlg.checkbox_geoservice_car.stateChanged.connect(self._change_status_car)
        
        
            # self.dlg.checkBox_cff.checkState.UnChecked.connect(self.dlg.doubleSpinBox.setEnabled(False))
            
            #menus de selction des couches qgis
            self.dlg.iso_choosing_layer_point.layerChanged.connect(self._change_iso_coords)
            self.dlg.dep_choosing_layer_point.layerChanged.connect(self._change_dep_coords)
            self.dlg.arr_choosing_layer_point.layerChanged.connect(self._change_arr_coords)
            
            
            self.dlg.push_ptal.clicked.connect(self._map_PTAL)
            
     ################### TODO : CODE A DEPLACER ################################
     ##########################################################################
    @property
    def graph(self):
        
        if nx.is_empty(self._graph):
            print("empty")
            gtfs_path = self.dlg.gtfs_finder.filePath()
            
            date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
            h_min = self.dlg.h_min.dateTime().time().hour()
            h_max = self.dlg.h_max.dateTime().time().hour()
            
            feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
            
            g = graphes(feed).gtfs_to_nx()
            
            self._graph = g
        else:
            print('not empty')
            g = self._graph
        return g
    
    @graph.setter
    def graph(self, value):
        self._graph = value
        
        
    # proprietes - setter :
    @property 
    def graphe(self):
        print("coucou")
        if self._graphe == None:
            print("Objet graphe à créer")
            # get informations from the form :
            gtfs_path = self.dlg.gtfs_finder.filePath()
            
            date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
            h_min = self.dlg.h_min.dateTime().time().hour()
            h_max = self.dlg.h_max.dateTime().time().hour()
            
            # instanciate a gtfs feed
            Feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
            
            self._graphe = graphes(Feed)
            
            return self._graphe
        else:
            print("Objet graphe existant")
            return self._graphe
    @graphe.setter
    def graphe(self, value):
        self._graphe = value

    def _fill_checkable_cbbox(self, value):
        
        self.dlg.checkable_lines.addItemWithCheckState(text=value, state = Qt.CheckState.Unchecked) #, checked = False)
        




    def _get_closest_tuesday(self, date_str):
        # Convertir la chaîne de caractères en objet datetime
        date = datetime.strptime(date_str, "%Y%m%d")
        
        # Trouver le jour de la semaine de la date (lundi=0, mardi=1, ..., dimanche=6)
        day_of_week = date.weekday()
        # Calculer la différence en jours pour atteindre le mardi le plus proche
        if day_of_week < 1:
            # Si le jour est avant mardi (lundi ou mardi)
            days_to_tuesday = 1 - day_of_week
        else:
            # Si le jour est après mardi (mercredi à dimanche)
            days_to_tuesday = 8 - day_of_week
        # Calculer la date du mardi le plus proche
        closest_tuesday_date = date + timedelta(days=days_to_tuesday)
        # pri//11nt("test")
        print(closest_tuesday_date)
        
        return closest_tuesday_date #.strftime("%Y%m%d")   
    
    
    def _fill_date(self):
        """
        Find the best date :  find the closest tuesday from the first date registred in the calendar file.

        Returns
        -------
        None.

        """
        fic = self.dlg.gtfs_finder.filePath()
        tmp_feed = gtfs_feed(fic, "19000101", [0,24])
        # services = feed.services()
        # on trouve la date la plus proche qui est un mardi        
        if tmp_feed.data("calendar").empty:
            date_str = str(tmp_feed.data("calendar_dates").date.min())
        else:
            date_str = str(tmp_feed.data("calendar").start_date.min()) 
        
        best_date = self._get_closest_tuesday(date_str)
   
        self.dlg.date_form.setDateTime(best_date)
        
            
    def change_networks_name(self, file):
        
        fic = file #self.dlg.gtfs_finder.filePath()
        print(file)
        feed = gtfs_feed(fic, '20240101', [0,25])
        if not feed.data('agency').empty:
            try:
                self.dlg.network_label.setText(feed.data('agency').agency_name.values[0])
            except:
                self.dlg.network_label.setText('null')
        else:
            self.dlg.network_label.setText('null') 
        
        
        # fill the checkable combobox :
        routes = feed.routes.route_short_name.unique()
        # if the combobox amready contains values we must remove these values first
        if self.dlg.checkable_lines.count() != 0:
            for index in range(self.dlg.checkable_lines.count()):
                self.dlg.checkable_lines.removeItem(index)
            
        for route in routes:
            self._fill_checkable_cbbox(route)   
            
            
        # fill date time with the closest_tuesday method :
        self._fill_date()
        
        # active/desactive certaines fonctionnalités si le shape est présent :
        if not feed.data("shapes").empty:
            self.dlg.push_draw_frq.setEnabled(True)
            self.dlg.push_draw_network.setEnabled(True)
        else:
            self.dlg.push_draw_frq.setEnabled(False)
            self.dlg.push_draw_network.setEnabled(False)   
            
            
            
        # remplir les données calendaires du gtfs (gtfs infos):
        c = feed.data("calendar_dates")
        c = c[c.exception_type!=2]
        c = c[['service_id', "date"]].groupby('date').count().reset_index()
        
        max_trips = str(c[c.service_id==c.service_id.max()].iloc[0].date)
        min_date = str(c[c.date==c.date.min()].iloc[0].date)
        max_date = str(c[c.date==c.date.max()].iloc[0].date)
        # print(f"test : {max_trips}")
        self.dlg.max_trips.setText(max_trips[-2:] + max_trips[4:-2] + max_trips[:4])
        self.dlg.min_date.setText(min_date[-2:] + min_date[4:-2] + min_date[:4])
        self.dlg.max_date.setText(max_date[-2:] + max_date[4:-2] + max_date[:4])
        
        
        
    def map_network(self):
        
        fic = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        # print(date, h_min, h_max)
        feed = gtfs_feed(fic, date, [h_min, h_max])
        perfs = performances(feed)
        
        gdf = perfs.traces_des_lignes()
        
        # Créer un fichier temporaire (Shapefile ou GeoPackage)
        temp_dir = tempfile.gettempdir()
        temp_shapefile = os.path.join(temp_dir, "temp_layer.shp")
        
        # Sauvegarder le GeoDataFrame dans ce fichier temporaire
        gdf.to_file(temp_shapefile)
        
        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(temp_shapefile, "Lignes de TC", "ogr")
        
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")
            
            
    def map_freq(self):
        
        fic = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        # print(date, h_min, h_max)
        feed = gtfs_feed(fic, date, [h_min, h_max])
        perfs = performances(feed)
        
        gdf = perfs.traces_des_lignes()
        gdf.shape_id = gdf.shape_id.astype(str)
        
        df_frq = perfs.frequence_par_shapes()
        df_frq.shape_id = df_frq.shape_id.astype(str)
        
        
        gdf = gdf.merge(df_frq, on="shape_id")
        
        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(gdf.to_json(), "Frequence horaire", "org")
        
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")
                
    def map_seg_freq(self):
        
        fic = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        # print(date, h_min, h_max)
        feed = gtfs_feed(fic, date, [h_min, h_max])
        perfs = performances(feed)
        
        gdf = perfs.frequence_par_segment()
        # choisir la direction_id :
        dir_id = self.dlg.spinBox.value()
        gdf = gdf[gdf.direction_id == dir_id]
        layer = QgsVectorLayer(gdf.to_json(),"Frequence horaire","ogr")
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")
                      
    def closeness_centrality(self):
    
        gtfs_path = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
        
        graphe = graphes(feed)
        g = self.graph
        # print(len(graphe.table_noeuds()))
        cc = graphe.closeness_centrality(graph = g)
        # print(len(cc))
        df_cc = nxbetweenness_to_df(cc, "cc")
        gdf_cc = nbc_to_gdf(df_cc, graphe.table_noeuds(), "cc")
        
        # gdf = perfs.traces_des_lignes()
        
        # Créer un fichier temporaire (Shapefile ou GeoPackage)
        temp_dir = tempfile.gettempdir()
        temp_shapefile = os.path.join(temp_dir, "temp_layer_cc.shp")
        
        # Sauvegarder le GeoDataFrame dans ce fichier temporaire
        gdf_cc.to_file(temp_shapefile)
        
        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(temp_shapefile, "Closeness Centrality", "ogr")
        
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")
        
    def betweenness_centrality(self):
        gtfs_path = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
        
        graphe = graphes(feed)
        g = self.graph
        
        ###♦ Calcul betweenness centrality
        if not self.dlg.ebc_checkbox.isChecked():
            bc = graphe.betweenness_centrality(graph = g)
            df_bc = nxbetweenness_to_df(bc, "bc")
            gdf_bc = nbc_to_gdf(df_bc, graphe.table_noeuds(), "bc")
            layer_name="Betweenness Centrality"
# =============================================================================
#         calcul edge betwenness centrality
# =============================================================================
        if self.dlg.ebc_checkbox.isChecked():
            layer_name = "Edge Betweenness Centrality"
            # Calcul EBC :
            ebc = nx.edge_betweenness_centrality(g, weight="cost" ) 
            
            # chargement des tables de noueds et de segments
            table_noeuds = graphe.table_noeuds()
            # table_noeuds
            tb_seg = graphe.table_segments()
            # on fusionne les tables de noeuds/segments pour avoir les noms des arrets :
            tb_seg = tb_seg.merge(table_noeuds[['stop_id', 'stop_name']],
                         left_on = "start_stop_id",
                        right_on = "stop_id").drop(columns = 'stop_id')\
            .merge(table_noeuds[['stop_id', 'stop_name']],
                         left_on = "end_stop_id",
                        right_on = "stop_id", suffixes=("_start", "_dep")).drop(columns = 'stop_id')
            
            tb_seg["edge"] = tb_seg["start_stop_id"] + ' - ' + tb_seg['end_stop_id']
            tb_seg["edge_name"] = tb_seg["stop_name_start"] + ' - ' + tb_seg['stop_name_dep']
            # tb_seg
            
            # on fusionne les tables pour avoir les ebc par segment nommés, puis on somme par segment identique
            df_ebc = pd.DataFrame.from_dict(ebc, orient = "index").reset_index()
            df_ebc['u'] = [x[0] for x in df_ebc['index'].values]
            df_ebc['v'] = [x[1] for x in df_ebc['index'].values]
            df_ebc['edge'] = df_ebc['u'] + " - " + df_ebc['v']
            df_ebc['EBC'] = np.log(df_ebc[0])
            df_ebc = df_ebc[['u', 'v', "edge", 'EBC']]
            df_ebc = df_ebc.merge(tb_seg)#[['EBC', 'edge_name']]
            # df_ebc = df_ebc.groupby('edge_name').sum().reset_index()
            
            # on récupère les coords des sommets des segments :
            lines = []
            for e in df_ebc[["u", "v"]].to_numpy():
                u = table_noeuds[table_noeuds.stop_id == e[0]][['x', 'y']].to_numpy()
                v = table_noeuds[table_noeuds.stop_id == e[1]][['x', 'y']].to_numpy()
                lines.append(LineString([Point(u), Point(v)]))
            # on créé les géométries :
            tmp_geom = gpd.GeoDataFrame(data = df_ebc[['edge_name']],
                            geometry = gpd.GeoSeries(lines), crs = 2154)
            tmp_val = df_ebc[['edge_name', "EBC"]].groupby('edge_name').sum().reset_index()
            
            gdf = tmp_geom.merge(tmp_val, on = "edge_name").drop_duplicates()
            
            gdf_bc = gdf.drop_duplicates().dropna()
        
        # Créer un fichier temporaire (Shapefile ou GeoPackage)
        temp_dir = tempfile.gettempdir()
        temp_shapefile = os.path.join(temp_dir,
                                      "temp_layer_bc.shp")
        
        # Sauvegarder le GeoDataFrame dans ce fichier temporaire
        gdf_bc.to_file(temp_shapefile)
        
        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(temp_shapefile, layer_name,
                               "ogr")            
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")   
            

            
    def degree_centrality(self):
        
        gtfs_path = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
        
        graphe = graphes(feed)
        G = self.graph
        
        d_c = nx.degree_centrality(G)
        df_dc = nxbetweenness_to_df(d_c, col="dc")
        gdf_dc = nbc_to_gdf(df_dc, col='dc', table_noeuds=graphe.table_noeuds())
        
        # Créer un fichier temporaire (Shapefile ou GeoPackage)
        temp_dir = tempfile.gettempdir()
        temp_shapefile = os.path.join(temp_dir, "temp_layer_dc.shp")
        
        # Sauvegarder le GeoDataFrame dans ce fichier temporaire
        gdf_dc.to_file(temp_shapefile)
        
        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(temp_shapefile, "Degree Centrality", "ogr")
        
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")
            
    def _find_the_nearest_point(self, x, y, graphe):
        # get the coordinates of the graph nodes :
        nodes = graphe.table_noeuds()
        
        try:
            distance = np.sqrt((x - nodes.x.values)**2 + (y - nodes.y.values)**2)
            index_nearest_node = np.argmin(distance)
            nearest_node = nodes[nodes.index == index_nearest_node].stop_id.iloc[0]
        except:
            print("nearest node not found")
        
        return nearest_node
    
    
    def plot_isochrones(self):
         
        gtfs_path = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
        
        graphe = graphes(feed)  
        
        g = self._graph
        point = self.dlg.coordinates_iso.text()
        print(point)
        x = float(point.split(',')[0])
        y = float(point.split(',')[1])
        # print(x, y)
        nearest_node = self._find_the_nearest_point(x,y, graphe)
        # print(nearest_node)
        
        temps_secondes = list()
        labels = list()
        
        # # on récupère la taille spécifiée du buffer en metres
        # buffer = int(self.dlg.spin_buffer.value()) # metres
        # # on convertit cette valeur en secondes, après avoir récupéré la vitesse de déplacements spécifiée
        # speed_buffer = float(self.dlg.spin_speed_iso.value()) / 3.6 #$ conversion km/h en m/s
        # time_buffer = buffer / speed_buffer # secondes
        
        # ensuite on récupère les checkbox et on retire le temps en secondes pour parcourir la distance du buffer:
# =============================================================================
#  # TODO : on pourrait améliorer en faisant un "vrai" isochrones  : récupérer chaque point atteignable en m minutes 
#         # puis de chacunb de ses points, en récupréant le temps qu'il a fallu pour l'atteindre,
#         ajouter un buffer qui correspond à la distance parcourable avec le temps restant
# =============================================================================
        if self.dlg.checkBox.isChecked():
            temps_secondes.append(5*60)
            labels.append('5min')
        if self.dlg.checkBox_2.isChecked():
            temps_secondes.append(10*60)   
            labels.append('10min')
        if self.dlg.checkBox_3.isChecked():
            temps_secondes.append(15*60)
            labels.append('15min')
        if self.dlg.checkBox_4.isChecked():
            temps_secondes.append(30*60)
            labels.append('30min')
        if self.dlg.checkBox_5.isChecked():
            temps_secondes.append(45*60)
            labels.append('45min')
        if self.dlg.checkBox_6.isChecked():
            temps_secondes.append(60*60)
            labels.append('1h')
        if self.dlg.checkBox_7.isChecked():
            temps_secondes.append(3*60*60)
            labels.append('3h')
        if self.dlg.checkBox_8.isChecked():
            temps_secondes.append(6*60*60)
            labels.append('6h')            
            
            

        # # appel à la methode isochrones de la classe graohes()
        # iso = graphe.isochrones(graph = g,
        #                   source = nearest_node,
        #                   # source = graphe.table_noeuds().iloc[nearest_node].stop_id,
        #                   temps_secondes=temps_secondes, labels=labels)
        
        
        if self.dlg.checkbox_geoservice_pedestrians.isChecked():
            geoservice = True
            mode = "pedestrian"
        elif self.dlg.checkbox_geoservice_car.isChecked():
            geoservice = True
            mode = "car"
        else:
            geoservice = False
            mode = "none"
        print(geoservice, mode)
        iso = graphe.isochrones(graph = g, 
                                       source = nearest_node,
                                       temps_secondes=temps_secondes,
                                       labels=labels,
                                       crs = 'epsg:2154',
                                       speed = float(self.dlg.spin_speed_iso.value()),
                                       geoservice=geoservice, mode=mode)
            
        iso.sort_index(ascending=False,inplace=True)  
        
        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(iso.to_json(), "isochrones", "ogr")
        
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")    
                
    def _map_PTAL(self):
       
        gtfs_path = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
        
        ptal_gdf = PTAL(feed, size=self.dlg.sb_size.value())._get_compute_ptal()
        # print(ptal_gdf.head())
        
        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(ptal_gdf.to_json(), "PTAL", "ogr")
        
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")        
       

    def _get_path_compute_route(self, max_transfers):
        
        """
        pick up coordinates from departure and arrival text boxes and compute
        the shortest path minimizing tranfers.
        Based on Djisktra algorithm
        """

        # instaciate a gtfs graph :
        graphe = self.graphe
        # graphe.distance(self, value)/
        # TODO : possible de changer les paramètres de marche et de distance max ?
        print(graphe.distance)
        print(self.dlg.spin_transfer_dist.value())
        
        if graphe.distance == self.dlg.spin_transfer_dist.value():
            recalcul_graphe = False
            print("pas de recalcul du graphe - distance identique")
        else:
            graphe.distance = self.dlg.spin_transfer_dist.value()
            recalcul_graphe = True
            print("recalcul du graphe - distance modifiee")
            
        if graphe.vitesse_marche == self.dlg.spin_vitesse_marche.value():
            recalcul_vitesse = False
            print("pas de recalcul du graphe - vitesse identique")
            
        else:
            graphe.vitesse_marche = self.dlg.spin_vitesse_marche.value()
            recalcul_vitesse = True
            print("recalcul du graphe - vitesse modifiee")
            
        if (recalcul_graphe == True) | (recalcul_vitesse == True):
            print("recalcul ... ")
            self.graph = graphe.gtfs_to_nx()
        
        g = self.graph
        # pick up departure and arrival points :
        point = self.dlg.coordinates_departure.text()
        # print(point)
        x_dep = float(point.split(',')[0])
        y_dep = float(point.split(',')[1])
        # print(x, y)
        source = self._find_the_nearest_point(x_dep,y_dep, graphe)
        # print(nearest_node)
        point = self.dlg.coordinates_arrival.text()
        # print(point)
        x_arr = float(point.split(',')[0])
        y_arr = float(point.split(',')[1])
        # print(x, y)
        target = self._find_the_nearest_point(x_arr,y_arr, graphe)
        
        if self.dlg.combo_algo.currentText() == "Dijsktra with max transfers":
            res = graphe.dijkstra_min_transfers(graph=g, source = source,
                                                target = target,
                                                max_transfers=int(max_transfers))
            
            path = res[2]
            # print(path)
            travel_time = res[0]
                
            return path, travel_time
        
        if self.dlg.combo_algo.currentText() == "Dijsktra":
            
            path = nx.dijkstra_path(G=g, source = source,
                                                target = target, weight='cost')
            
            print(path)
            return path, ''
        else:
            
            
            path = nx.dijkstra_path(G=g, source = source, target = target)
            print(path)
            return path, ''


    
    def compute_route(self):
        time = list()
        modes = list()
        routes = list()
        """get path from self._get_path_compute_route method and converts it in a qgis layer"""
        gtfs_path = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        # instanciate a gtfs feed
        feed = gtfs_feed(gtfs_path, date, [h_min, h_max])
        # instaciate a gtfs graph :
        graphe = graphes(feed)  
        path = self._get_path_compute_route(max_transfers = self.dlg.max_transfers.value())[0]
        nodes = graphe.table_noeuds()
        # on charge le graphe
        # si le graphe
        g = self.graph
        ls = list()# liste vide pour contenir les linestrings du path
        for u, v in zip(path[:-1], path[1:]):
            # print(nodes[nodes.stop_id == u][['x', "y"]].to_numpy()[0])
            xu, yu = nodes[nodes.stop_id == u][['x', "y"]].to_numpy()[0]
            xv, yv = nodes[nodes.stop_id == v][['x', "y"]].to_numpy()[0]

            ls.append(LineString([Point([xu, yu]),
                        Point([xv, yv])]))
            
            # récuperer les infos des edges :
            if "route" in list(g.edges()[u, v].keys()):
                route = g.edges()[u, v]['route']
            else:
                route = ""
            
            if "mode" in list(g.edges()[u, v].keys()):
                mode = g.edges()[u, v]['mode']
            else:
                mode = ""
                
            time.append(g.edges()[u, v]['cost'])
            
            routes.append(route)
            
            modes.append(mode)
            
        gos = gpd.GeoSeries(ls)
        
        gdf = gpd.GeoDataFrame(data = pd.DataFrame(zip(routes, modes, time),
                                                   columns = ['route', 'mode', 'time']),
                               geometry = gos)
        
        time = gdf.time.sum() / 60
        
        self.dlg.travel_time.setText(f"{round(time, 1)} minutes")

        # Charger le fichier temporaire dans QGIS comme une couche
        layer = QgsVectorLayer(gdf.to_json(), "route", "ogr")
        
        # Vérifier si la couche est valide, puis l'ajouter au projet
        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
        else:
            print("Échec du chargement de la couche.")   

        return gos
        
    def activateCaptureTool(self, code):
        # Activer l'outil de capture sur le canvas
        self.canvas.setMapTool(self.captureTool)
        self.activeButton = code

    def handlePointCaptured(self, point):
        # Traiter les coordonnées capturées (par exemple, les afficher)
        # 
        if self.activeButton == "iso":

            self.dlg.coordinates_iso.setText(f"{round(point.x(), 3)}, {round(point.y(), 3)}")
        if self.activeButton == "dep":
            self.dlg.coordinates_departure.setText(f"{round(point.x(), 3)}, {round(point.y(), 3)}")
        if self.activeButton == "arr":
            self.dlg.coordinates_arrival.setText(f"{round(point.x(), 3)}, {round(point.y(), 3)}")      
            
        # Désactiver l'outil après la capture (optionnel)
        self.canvas.unsetMapTool(self.captureTool) 
        
    def add_point_to_layer(self, point):
        # print("coucou")
        # Créer une couche vectorielle pour stocker les points
        point_layer = self.create_point_layer()
        
        # Ajouter un point à la couche vectorielle
        prov = point_layer.dataProvider()
        print(point)
        # Créer une nouvelle entité avec le point capturé
        feature = QgsFeature()
        feature.setGeometry(QgsGeometry.fromPointXY(point))
        feature.setAttributes([point_layer.featureCount() + 1])

        # Ajouter l'entité à la couche
        prov.addFeatures([feature])
        point_layer.updateExtents()
        point_layer.triggerRepaint()
        # print(f"Point ajouté : {point.x()}, {point.y()}")
        
        
    def create_point_layer(self):
        # Créer une couche vectorielle temporaire de type point
        layer = QgsVectorLayer("Point?crs=EPSG:2154", "Point", "memory")
        prov = layer.dataProvider()
    
        # Ajouter un champ pour les identifiants ou les métadonnées
        prov.addAttributes([QgsField("id", QVariant.Int)])
        layer.updateFields()
    
        # Ajouter la couche à la carte
        QgsProject.instance().addMapLayer(layer)
        
        return layer
            
    def plot_evolution(self):
        
        fic = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        
        # print(date, h_min, h_max)
        feed = gtfs_feed(fic, date, [h_min, h_max])
        
        liste_ligne_a_tracer = self.dlg.checkable_lines.checkedItems()
        
        feed.plot_evol_journaliere(titre = "Evolution journalière",
                                  x_axe = None, y_axe_1 = "évol. ens. des lignes [nombre]",
                                  liste_ligne_a_tracer = liste_ligne_a_tracer,
                                  y_axe_2="évol. lignes spécif. [nombre]")
    def table_perfs(self, fic, date, plage_horaire):

        # # on charge le GTFS avec la date correcte :
        Feed = gtfs_feed(fic, date, [5,23])        

        # creation objet feed selon librairie perso :
        Feed79 = gtfs_feed(fic, date, [7,9])
        Feed1214 = gtfs_feed(fic, date, [12,14])
        Feed1619 = gtfs_feed(fic, date, [16,19])
        print("test_1")
        perfs_79 = performances(Feed79)
        perfs_1214 = performances(Feed1214)
        perfs_1619 = performances(Feed1619)

        # amplitude journalière par ligne :
        amp = perfs_79.amplitude_par_ligne()
        # fréquences selon horaire :
        freq79 = perfs_79.frequence_par_ligne(stop_sequence=2)
        freq1214 = perfs_1214.frequence_par_ligne(stop_sequence=2)
        freq1619 = perfs_1619.frequence_par_ligne(stop_sequence=2)
        # calcul du nombre de services par jour :
        nb_services_par_jour = Feed.table_horaire()
        nb_services_par_jour = nb_services_par_jour[['route_short_name', 'trip_id', 'direction_id']].drop_duplicates()
        nb_services_par_jour = nb_services_par_jour.groupby(['route_short_name', 'direction_id'])\
                .count().reset_index().sort_values(by='trip_id', ascending = False)
        # fréquence minimale par ligne par jour
        freq_min_ligne = perfs_79.freq_min(stop_sequence=4)
        print("test_2")
        # fusion des tables
        table_etudes = nb_services_par_jour.merge(freq79, on =['route_short_name', 'direction_id']).\
        merge(freq1214, on =['route_short_name', 'direction_id']).\
        merge(freq1619, on =['route_short_name', 'direction_id']).\
        merge(amp, on = "route_short_name")
        # renomme les colonnes :
        table_etudes.columns = ["route_short_name","direction_id","services par jour",
                                "nbtrips_x","freq. moy. de 7 à 9","nbtrips_y","freq. moy. de 12 à 14",
                                "nbtrips" , "freq. moy. de 16 à 19", "hmin","hmax", "amplitude(sec.)"]
        # # garde uniquement les colonnes :
        table_etudes = table_etudes[["route_short_name","direction_id","services par jour",
                                "freq. moy. de 7 à 9","freq. moy. de 12 à 14",
                                "freq. moy. de 16 à 19", "hmin","hmax", "amplitude(sec.)"]]
        
        # # fusion avec la table des frequences minimales :
        table_etudes = table_etudes.merge(freq_min_ligne, on = "route_short_name")
        
    # ================================================================================================================== #
    #                                              Pour l'ensemble des lignes 
    # ================================================================================================================== #
        # print(table_etudes)
        table_finale = table_etudes.copy()
        
        stops = Feed.stops
        # print("test_3")
        for segments_freq, coef, ph in zip([perfs_79.frequence_par_segment(coords=True),
                                         perfs_1214.frequence_par_segment(coords=True),
                                            perfs_1619.frequence_par_segment(coords=True)],
                                        [2, 2, 3], ["7 a 9", "12 a 14", "16 a 19"]):
        
            moy_pond_fr = list()
            min_fr = list()
            max_fr = list()
            
            for tmp in table_etudes.iterrows():
                
                ligne = tmp[1].route_short_name
                direction_id = tmp[1].direction_id
                segments = segments_freq[(segments_freq.route_short_name == ligne) &
                                      (segments_freq.direction_id == direction_id)]
                
                gs = sections(segments)
                try:
                    gda = gs.decoupe_auto(stops) 
        
                    moy_pond_fr.append(np.average(gda["nb_trips"], weights=gda["part d'offre"]))
        
                    min_fr.append(min(gda["frequence horaire moyenne (min)"]))
                    max_fr.append(max(gda["frequence horaire moyenne (min)"]))
                    
                except nx.NetworkXNoPath as e:
                    print(e.args)
                    moy_pond_fr.append(np.nan)
        
                    min_fr.append(np.nan)
                    max_fr.append(np.nan)
                    # 'frequence horaire moyenne (min)', 'frequence moyenne corrigée'
                
            table_finale["freq. moy. corrigee   -    {}".format(ph)] = coef * 60 / np.array(moy_pond_fr)
            table_finale["min freq. moy. corrigee -  {}".format(ph)] = np.array(min_fr) * coef
            table_finale["max freq. moy. corrigee -  {}".format(ph)] = np.array(max_fr) * coef
            
        # print(table_finale)
        
        return table_finale   
    
    def _get_perfs(self):
        
        fic = self.dlg.gtfs_finder.filePath()
        
        date = self.dlg.date_form.dateTime().toString('yyyyMMdd')
        h_min = self.dlg.h_min.dateTime().time().hour()
        h_max = self.dlg.h_max.dateTime().time().hour()
        # print(fic, date, [h_min, h_max])
        # TODO : corriger cette erreur de columns none type
        df = self.table_perfs(fic, date, [h_min, h_max])
        # print(df)
        if df.empty:
            print("Erreur : Le DataFrame est vide.")
            
        print(df.columns)
        
        liste_indicateurs = self.dlg.combo_select_indicators.checkedItems()
        
        df = round(df[liste_indicateurs], 2)
        
        # Creation of my QgsVectorLayer with no geometry 
        temp = QgsVectorLayer("none","result","memory")
        # temp_data = temp.dataProvider()
        # Start of the edition 
        temp.startEditing()
        
        # Creation of my fields 
        for head in df:
            dtype = QVariant.String if df[head].dtype == "object" else QVariant.Double
            myField = QgsField( head, dtype)
            temp.addAttribute(myField)
        # Update     
        temp.updateFields()
        
        # Addition of features
        # [1] because i don't want the indexes 
        for _, row in df.iterrows():
            f = QgsFeature()
            # print(row[1])
            f.setAttributes(row.tolist())
            temp.addFeature(f)
            # print(row)
        # saving changes and adding the layer
        temp.commitChanges()
        temp.updateExtents()
        QgsProject.instance().addMapLayer(temp)

    # Appeler la fonction
    # pandas_to_qgis_table(df, layer_name="My Pandas Data")
    def _change_status_cbx(self):
        if self.dlg.checkBox_cff.isChecked():
            self.dlg.doubleSpinBox.setEnabled(True)
        else:
            self.dlg.doubleSpinBox.setEnabled(False)
            
    def _change_status_pedestrian(self):
        if self.dlg.checkbox_geoservice_pedestrians.isChecked():
            self.dlg.spin_speed_iso.setEnabled(False)
            if self.dlg.checkbox_geoservice_car.isChecked(): 
                self.dlg.checkbox_geoservice_car.setChecked(False)
        else:
            self.dlg.spin_speed_iso.setEnabled(True)
            
    def _change_status_car(self):
        if self.dlg.checkbox_geoservice_car.isChecked():
            self.dlg.spin_speed_iso.setEnabled(False)
            if self.dlg.checkbox_geoservice_pedestrians.isChecked(): 
                self.dlg.checkbox_geoservice_pedestrians.setChecked(False)
        else:
            self.dlg.spin_speed_iso.setEnabled(True)
            
    def _change_iso_coords(self):
        selected_layer = self.dlg.iso_choosing_layer_point.currentLayer()
        # Parcourir les entités de la couche
        for feature in selected_layer.getFeatures():
            geometry = feature.geometry()
            if geometry.isEmpty():
                continue
        # Récupérer les coordonnées du point
        point = geometry.asPoint()
        self.dlg.coordinates_iso.setText(f"{round(point.x(), 3)}, {round(point.y(), 3)}")
    
    def _change_dep_coords(self):
        selected_layer = self.dlg.dep_choosing_layer_point.currentLayer()
        # Parcourir les entités de la couche
        for feature in selected_layer.getFeatures():
            geometry = feature.geometry()
            if geometry.isEmpty():
                continue
        # Récupérer les coordonnées du point
        point = geometry.asPoint()
        self.dlg.coordinates_departure.setText(f"{round(point.x(), 3)}, {round(point.y(), 3)}")
        
    def _change_arr_coords(self):
        selected_layer = self.dlg.arr_choosing_layer_point.currentLayer()
        # Parcourir les entités de la couche
        for feature in selected_layer.getFeatures():
            geometry = feature.geometry()
            if geometry.isEmpty():
                continue
        # Récupérer les coordonnées du point
        point = geometry.asPoint()
        self.dlg.coordinates_arrival.setText(f"{round(point.x(), 3)}, {round(point.y(), 3)}")